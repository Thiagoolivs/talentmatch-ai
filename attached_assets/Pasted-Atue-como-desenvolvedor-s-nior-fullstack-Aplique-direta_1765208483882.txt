Atue como desenvolvedor sênior fullstack. Aplique diretamente no projeto existente sem renomear arquivos ou pastas e sem apagar código funcional. Faça apenas as adições, integrações e ajustes mínimos necessários para implementar os requisitos abaixo. Não crie nomes de arquivos no código gerado e não escreva chaves/segredos em texto plano no repositório. Use variáveis de ambiente para qualquer segredo. Se for necessário criar rotinas administrativas, utilize checagens idempotentes (não duplicam registros caso já existam).

Autocorreção e padronização de habilidades

Crie e exponha uma lista canonical de competências para uso pelo algoritmo de matching.

Ao salvar/editar habilidades, normalize: remover acento, trim, lowercase.

Use correspondência por similaridade (biblioteca padrão do Python) para encontrar a melhor correspondência na lista canonical. Se a similaridade for acima de um limiar razoável, substitua automaticamente pelo termo canonical; caso contrário, salve o termo do usuário e marque para revisão.

Garanta que o campo persistido no banco esteja sempre padronizado para o matching.

Forneça logs/contadores de correções automáticas para auditoria.

Sistema de mensagens bidirecional vinculado à candidatura

Implemente um fluxo de mensagens entre empresa ↔ candidato que seja vinculado à candidatura/vaga correspondente.

Mensagens contêm: remetente, destinatário, texto, timestamp, referência opcional à candidatura.

Forneça endpoints/views para listar conversas do usuário e exibir o histórico de uma conversa com paginação/ordenamento cronológico.

Permita envio assíncrono via requisição AJAX ou fallback por formulário normal.

Mostre indicador simples de mensagens não lidas.

Exponha botão “Enviar mensagem” na interface de candidatura/vaga para iniciar conversa.

Criação e acesso explícito do administrador

Garanta criação idempotente de uma conta administrativa padrão com credenciais: usuário = administrador, senha = TalentMatch2025.

A conta administrativa só é criada se não existir.

No layout global, exiba link visível “Administrador” quando o usuário autenticado tiver permissões administrativas.

Projete tela de login/fluxo normal; não exponha credenciais em repositórios.

Aprovação manual de empresas antes do uso completo

Adicione uma flag de aprovação para contas empresariais (default: pendente).

Bloqueie funcionalidades empresariais para contas não aprovadas (publicar vagas, ver candidaturas, acessar dashboard empresarial).

No painel administrativo, exiba lista de empresas pendentes com ações “Aprovar” e “Negar”.

Envie notificação simples por e-mail ou sistema interno ao aprovar/recusar (opcional dependendo do setup de e-mail).

Garanta registro de quem aprovou e o timestamp.

Histórico de candidaturas com status e notificações

Para cada candidatura, mantenha status: enviado, visto, analisando, aprovado, reprovado, entrevista agendada.

Permita que empresa atualize status; registre histórico de mudanças (who/when/old->new).

Envie notificações básicas ao candidato quando o status mudar (in-app; e-mail se o projeto já tiver suporte).

Exiba status atual em listagens e detalhe da candidatura.

Modo manutenção controlado pelo administrador

Crie chave global de configuração para modo manutenção.

Painel administrador permite ativar/desativar modo manutenção.

Quando ativo: visitantes não autenticados veem página simples de manutenção; empresas pendentes continuam bloqueadas; administrador continua com acesso normal.

Log de quem ativou/desativou e quando.

Gerenciamento completo de contas pelo administrador (exclusão segura)

No painel admin, adicione seção para gerenciar usuários e empresas com busca por nome/email/ID e filtros por tipo.

Permita exclusão com confirmação (modal).

Ao excluir empresa: desative/remova vagas associadas, marque candidaturas como encerradas e remova mensagens vinculadas.

Ao excluir candidato: remova candidaturas e mensagens vinculadas.

Regra: administrador não pode excluir a si mesmo.

Preferência: implemente exclusão lógica (arquivar/desativar) com opção de exclusão permanente, e registre auditoria de cada ação.

Proteção contra exposição de chaves e secrets no Replit / repositório

Antes de commitar qualquer mudança, execute verificação programática para strings que correspondam a padrões comuns de chaves (ex.: padrões de API keys, tokens, strings longas com combinações alfanuméricas). Se encontrado, a rotina deve abortar e instruir a mover a credencial para variável de ambiente.

Não escreva valores de variáveis de ambiente ou secrets em qualquer arquivo no repositório.

Garanta que qualquer configuração de runtime para Replit defina chaves via ambiente e que o projeto leia desses envvars.

Remova/limpe automaticamente quaisquer arquivos de assets que contenham conteúdos colados acidentalmente com segredos antes do commit.

Integração visual e experiência do administrador

Painel do administrador com métricas: total de usuários, total de empresas, total de candidatos, total de vagas, total de candidaturas, total de cursos, total de mensagens.

Painel com lista de empresas pendentes e controles de aprovação/reprovação; controls para modo manutenção; seção para gerenciar contas (edição, busca, exclusão); log de auditoria.

Interface limpa, responsiva, mantendo os estilos e paleta já existentes (branco e azul).

Botões com confirmações e mensagens claras.

Testes e checklist pós-implantação (automático/manual)

Scripts simples ou checklist automatizado para testar: criação de usuário admin; login admin; aprovar empresa; criar vaga como empresa aprovada; candidatar-se como candidato; enviar mensagem candidato→empresa e empresa→candidato; mudar status de candidatura; ativar modo manutenção e verificar bloqueios; excluir usuário/empresa; checar que secrets não estão no repositório.

Forneça instruções curtas de linha de comando para rodar migrações, criar dados seed (cursos fictícios) e criar admin caso necessário; faça isso via rotinas idempotentes no código (não coloque essas credenciais no repo).

Boas práticas e observações finais

Todas as alterações devem ser idempotentes e seguras para rodar em ambiente com dados já existentes.

Evitar sobrescrever modelos já existentes sem checagem.

Qualquer integração externa (envio de e-mails, APIs) deve depender exclusivamente de variáveis de ambiente; se a variável não existir, a funcionalidade deve degradar graciosamente sem falhar o sistema.

Fornecer comentários mínimos no código, claros e técnicos, sem expor informações sensíveis.

Ao terminar, gere um breve relatório de alterações aplicadas (quem/onde/ação), um checklist de testes executados e, se encontrou qualquer segredo no repositório, liste-os (apenas nomes dos arquivos/linhas detectadas — não revele os valores) e as ações tomadas (remoção/arquivamento/solicitação de rotação de chave).